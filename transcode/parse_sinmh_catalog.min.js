async function parseCatalog(url,options){const httpOptions={url,...options.httpOptions},clientOptions={encoding:"utf-8",...options.clientOptions},absoluteUrl=require("utils/absolute_url");let html;if(options.webview){const webviewFetch=require("webview_fetch");html=await webviewFetch(url,{mobile:1===clientOptions["x-mobile"],...options.webviewOptions});}else {const{send}=require("http");stat("request");let response=await send(httpOptions,clientOptions);if(stat("request"),null!=options.retry&&(response=await handleRequestRetry(response,httpOptions,clientOptions,send,options.retry)),options.fallbackToWebview&&options.fallbackToWebview(response)){const webviewFetch=require("webview_fetch");html=await webviewFetch(url,{mobile:1===clientOptions["x-mobile"],...options.webviewOptions});}else assertOK(response),html=response.body;}stat("parseRegex");stat("parseRegex");stat("fragment");let fragment=/<ul id="chapter-list-[^>]*>(?<fragment>(?:\s*<li>\s*<a[^>]*>\s*<span>[^<]*<\/span>\s*<\/a>\s*<\/li>)+)/.exec(html).groups.fragment;stat("fragment"),stat("matchAll");const matches=fragment.matchAll(/href="(?<url>[^"]+\d+\.html)"[^>]*>\s*<span>(?<name>[^<]+)</g);stat("matchAll");const catalog=[];stat("collect");for(let match of matches)if(null!=match.groups.name){const cid=/(?<id>\d+)\.html/.exec(match.groups.url).groups.id,record={id:cid,name:match.groups.name,url:absoluteUrl(match.groups.url,url)};catalog.push(record);}return stat("collect"),formatCatalog(catalog)}exports.parseCatalog=parseCatalog;